<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blender Shaders</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Blender shaders</a></li><li class="chapter-item expanded affix "><a href="shaders.html">What is a shader</a></li><li class="chapter-item expanded affix "><a href="shaders_and_textures.html">Shaders and Textures</a></li><li class="chapter-item expanded "><a href="mnode/index.html"><strong aria-hidden="true">1.</strong> The math node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mnode/sockets.html"><strong aria-hidden="true">1.1.</strong> Sockets</a></li><li class="chapter-item expanded "><a href="mnode/basic_ops.html"><strong aria-hidden="true">1.2.</strong> Basic operations</a></li><li class="chapter-item expanded "><a href="mnode/shape.html"><strong aria-hidden="true">1.3.</strong> Shape</a></li><li class="chapter-item expanded "><a href="mnode/repetition.html"><strong aria-hidden="true">1.4.</strong> Repetition</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> More Dimensions</div></li></ol></li><li class="chapter-item expanded "><a href="resources.html">Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Blender Shaders</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/WannesMalfait/Blender-shaders" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about-this-book" id="about-this-book">About this Book</a></h1>
<p>The goal of this book is to be a resource for people learning about procedural shaders in blender. It is still a <strong>work in progress</strong>. I don't know
everything, and will therefore not be able to cover everything. The shaders from this book are also not optimized, and serve only as a learning resource. I'm not the first person to write about shaders, so I highly recommend that you take a look at some other great sources as well. A list of these resources can be found <a href="resources.html">here</a>.</p>
<p>The book focuses on creating procedural shaders in blender, i.e. it is <strong>not</strong> a tutorial for blender itself. The early chapters are aimed at complete beginners, and serve as a replacement for my series on youtube: <a href="https://youtube.com/playlist?list=PLHwudW8KFVowaZMvH7DGsxSaHE_qPvX_k">Math in the node editor</a>.
Here we will look at how we can manipulate coordinates to create all sorts of cool effects. Later chapters will be more advanced and cover more interesting topics such as vector displacement. There will also be a small chapter on python scripting. Each chapter will have examples where we create shaders using the things we learned.</p>
<h2><a class="header" href="#acknowledgement" id="acknowledgement">Acknowledgement</a></h2>
<p>This book was written using <a href="https://github.com/rust-lang/mdBook">mdbook</a>. It would not have been possible without the loving community of Rustaceans. The graphs are from the fantastic website <a href="https://graphtoy.com/">graphtoy</a>, by Inigo Quilez.</p>
<h1><a class="header" href="#what-is-a-shader" id="what-is-a-shader">What is a shader</a></h1>
<p>Although there are varying definitions for what a shader is, a simple way to think about them is as programs that are run on a Graphics Processing Unit (GPU). A GPU, unlike a Central Processing Unit (CPU), is built to do a single operation many times in parallel very quickly. These operations can range from things like adding two numbers to calculating the sine of a value. This makes a GPU a very powerful tool when dealing with images, because images are made up of a large number of pixels that would take a long time to edit one at a time. The shaders that we will be looking at in this book are all so-called <em>fragment shaders</em>. Other types of shaders are vertex shaders, compute shaders and geometry shaders.</p>
<h2><a class="header" href="#fragment-shaders" id="fragment-shaders">Fragment shaders</a></h2>
<p>In the whole process of converting 3D data to a 2D image, the fragment shader or pixel shader is one of the last steps. Simply put, it's goal is to assign a color to a pixel. It takes as input a fragment (i.e. a collection of values like coordinates which were calculated in a previous step) as wel as some uniform variables. Uniform variables are external variables like the current time or the height and width of the image. Uniform values are the same for every pixel (thats where the name uniform comes from). Per fragment the shader outputs a pixel color. It is possible that multiple fragments end up in the same pixel, e.g think of  semi-transparent objects. After the fragment shader is done, some post-processing may be applied before the final image. </p>
<h2><a class="header" href="#what-you-need-to-know-for-blender" id="what-you-need-to-know-for-blender">What you need to know for blender</a></h2>
<p>When we make a shader in the node editor, you have to remember that everything we do is calculated at least once per pixel. When the shader is compiled it is passed to the processors in the GPU. These processors are independent (i.e. they do not know the values of the other processors) and forget what they computed in the previous step. In blenders node editor there is also no control flow, this means that common things from programming languages like if-statements and loops are not available. Increasing the number of samples means that the compiled shader is run multiple times, each time with a small random offset. These samples are then combined to create a smooth output image. </p>
<h1><a class="header" href="#shaders-and-textures" id="shaders-and-textures">Shaders and Textures</a></h1>
<p>The goal of this book is to build shaders with blenders node editor. Almost all shaders use a Texture node or a Shader node at some point. The good news is that we can already build a whole range of shaders using only a few of these nodes. We will now cover some of the more common Texture and Shader nodes, and go into more uses in later chapters. If you want to find more information about any node, it is always a good idea to look at <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/">the blender documentation</a>.</p>
<h2><a class="header" href="#shaders" id="shaders">Shaders</a></h2>
<p>When you create a new material, the default node tree has two nodes. One of these is the <code>Material Output</code> node which is the final output of the shader. The other is the <code>Principled BSDF</code> which is a very powerful all-in-one shader. By just changing the values of the <code>Principled BSDF</code>, you can get the basic look of most materials. This is the basis for most node trees, where textures are plugged into the sockets of the <code>Principled BSDF</code> to vary the material properties over the surface. On common way to use it, is to combine texture maps (think of diffuse map, roughness map, normal map, etc.) into one material. There is even a very easy way to do this if you have the node wrangler add-on enabled. Just press <code>CTRL + SHIFT + T</code> on the <code>Principled BSDF</code>, and select the maps you need. This book is for procedural shaders, however, so we won't be using image textures. </p>
<p>Other than the <code>Principled BSDF</code>, the most common surface shader nodes are the <code>Emission</code> shader and the <code>Glass BSDF</code> (Although you can technically use the <code>Principled BSDF</code>for these as well). The <code>Emission</code> shader is particularly interesting, because it does not interact with other rays in the scene, which makes it very easy to compute. For this reason the <code>Emission</code> shader is often used to preview the node tree at some point. With node wrangler, you can preview a node by pressing <code>SHIFT + CTRL + LMB</code> on that node. The <code>Glass BSDF</code> is used when creating glass like objects, but this does not come up very often when creating procedural shaders. </p>
<h2><a class="header" href="#textures" id="textures">Textures</a></h2>
<p>The two most common <code>Textures Nodes</code> are the <code>Noise Texture</code>, and the <code>Voronoi Texture</code>. The <code>Noise Texture</code> generates smooth variations which are layered on top of each other with different scales and amplitudes to create fractal noise. The amount of layers can be controlled with the <code>Detail</code> socket, with 0 being one smooth layer. The <code>Noise Texture</code> can be used to create natural looking surface variations and imperfections. To control the output of the texture, we can use the <code>Map Range</code> node, a node that we will cover in detail in later chapters. The <code>Voronoi Texture</code> creates cells which are very useful for shaders, where you need to distribute some things randomly over a surface. This can be things like cracks in ice or pebbles on the ground. </p>
<p float="left">
  <img src="images/noise.png" alt="Noise Texture" width="49.5%" />
  <img src="images/voronoi.png" alt="Voronoi Texture" width="49.5%" /> 
</p>
<p>The image on the left is a <code>Noise Texture</code>, and the image on the right is a <code>Voronoi Texture</code>.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>A car paint like material with varying roughness to mimic fingerprints. The <code>Map Range</code> node is used to increase the contrast in the texture, and limit the roughness to a range of <code>[0.05, 0.2]</code>. In practice the maximum roughness should be lower to create a more subtle effect. The idea is that you should only notice the imperfections if you remove them, but this way it's clearly visible on the final image. You can see the output of the <code>Map Range</code> node in the second image.
<img src="images/car_paint.png" alt="Car Paint" /> <img src="images/roughness.png" alt="Roughness" /></p>
<h1><a class="header" href="#your-journey-begins" id="your-journey-begins">Your journey begins</a></h1>
<p>In this chapter we will learn how to use math to create shaders. Before we begin I will share my setup for creating shaders in blender. In the beginning these shaders will all be 2D, and we will therefore use a plane as our primitive. If you already have your own setup that you're comfortable with, you can jump right to the <a href="mnode/basic_ops.html">next section</a>.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>Make sure that you have the node wrangler add-on enabled (it is a built-in plugin).</p>
<h3><a class="header" href="#layout" id="layout">Layout</a></h3>
<p>Starting from the default blend file open up the shading workspace. Then edit edit the layout so that the file explorer, render preview, and image editor are gone. It should look something like this:</p>
<p><img src="mnode/images/setup1.png" alt="First part of setup" /></p>
<p>Next change the outliner to the 3D viewport and replace the default cube with a plane. Make sure the default material is assigned to the plane. Then switch the view to top orthographic and turn off all overlays and gizmos. Turn switch the display to rendered. We will use this section as our shader preview. You can resize it to be bigger if you want. The final result should look something like this:</p>
<p><img src="mnode/images/setup2.png" alt="Final part of setup" /></p>
<p>If you want this to be the default every time you open blender you can go to &quot;File &gt; Defaults &gt; Save startup file&quot;. Optionally you can also start with <a href="mnode/blendfiles/default.blend">my default file</a>. </p>
<h1><a class="header" href="#sockets" id="sockets">Sockets</a></h1>
<p>When working with nodes, it is very important to keep in mind that the data that gets passed through the network can be of different types. The types used in the shader editor are: value, color, vector, and shader. The node sockets indicate the type of value the node expects as input and the type it outputs. You can easily see the type by looking at the color of the socket</p>
<ul>
<li>Values are indicated with greyish sockets</li>
<li>Colors are indicated with yellowish sockets</li>
<li>Vectors are indicated with blue/purplish sockets</li>
<li>Shaders are indicated with greenish sockets</li>
</ul>
<p>You can see the different types of sockets here:</p>
<p><img src="mnode/images/sockets.png" alt="Socket types" /></p>
<h2><a class="header" href="#different-types" id="different-types">Different types</a></h2>
<p>As long as we plug data of the same type into sockets of the right type, everything works fine. What happens when we connect two sockets of different types? Most of the time this will work, even though it might not do what you think it will. The only time it doesn't work is when you try to connect a shader socket with any other non-shader socket. In that case the connection will be made red, and the shader won't compile. If you want to convert a shader to a color you have to use the <code>Shader to RGB</code> node which only works in EEVEE. You can see the different possibilities here:</p>
<p><img src="mnode/images/sockets2.png" alt="Socket connections" /></p>
<p>So what happens when it does work? The answer depends on the types of the sockets. The following descriptions may not be one hundred percent accurate, but they do suffice for things that we need them for.</p>
<h3><a class="header" href="#color-socket" id="color-socket">Color socket</a></h3>
<p>The data stored in a color socket is made up of three values stored together as <code>(r, g, b)</code>. These are the red, green, and blue values of the color. Here are the possibilities for implicit conversion:</p>
<ul>
<li>Color -&gt; Shader. The color output gets treated as an emission shader with strength one.</li>
<li>Color -&gt; Vector. The <code>(r, g, b)</code> gets sent to <code>(x, y, z)</code>.</li>
<li>Color -&gt; Value. The returned value is the luminance: <code>0.2126729*r + 0.7151522*g + 0.0721750*b</code>. This is the same as the <code>Color to BW</code> node, and leaves grayscale values unchanged.</li>
</ul>
<h3><a class="header" href="#vector-socket" id="vector-socket">Vector socket</a></h3>
<p>The data stored in a vector socket is the same as the data stored in a color socket, except that the labels are now <code>(x, y, z)</code>. These are the conversions:</p>
<ul>
<li>Vector -&gt; Shader. Same as Vector -&gt; Color -&gt; Shader.</li>
<li>Vector -&gt; Color. The <code>(x, y, z)</code> gets mapped to <code>(r, g, b)</code>.</li>
<li>Vector -&gt; Value. The average is taken, i.e. \(\frac{1}{3}(x+y+z)\). Note that this is different from the conversion Color -&gt; Value.</li>
</ul>
<h3><a class="header" href="#value-socket" id="value-socket">Value socket</a></h3>
<p>This just stores one value, hence the name. </p>
<ul>
<li>Value -&gt; Shader. The output gets treated as an emission shader with color <code>(1.0, 1.0, 1.0)</code> (white) and strength the value.</li>
<li>Value -&gt; Color. The red, green, and blue channels are set to the value.</li>
<li>Value -&gt; Vector. The x, y and z components are set to the value.</li>
</ul>
<h3><a class="header" href="#summary" id="summary">Summary</a></h3>
<p>Converting between Color and Vector does nothing. Converting from Value to Vector or Color makes three copies of the value. Converting from Color to Value takes the luminance, and converting from Vector to Value takes the average. In this case information is lost, i.e. Vector -&gt; Value -&gt; Vector will not necessarily be the same as the original vector. Converting to Shader is done through an <code>Emission Shader</code>.</p>
<h2><a class="header" href="#separate-and-combine" id="separate-and-combine">Separate and Combine</a></h2>
<p>If you don't want to lose information because of implicit conversions, you can use the <code>Separate XYZ</code> node and the <code>Separate RGB</code> node to extract the individual components. If you then want to combine them later in the node tree you can use the <code>Combine XYZ</code> and <code>Combine RGB</code> nodes.</p>
<hr />
<h2><a class="header" href="#blender-documentation" id="blender-documentation">Blender documentation</a></h2>
<p>You can find more info <a href="https://docs.blender.org/manual/en/latest/interface/controls/nodes/parts.html#conversion">here</a>.</p>
<h2><a class="header" href="#source-code" id="source-code">Source code</a></h2>
<p>The information for how the conversion works, is based on the following snippets in the blender source. </p>
<p>intern\cycles\render\graph.cpp</p>
<pre><code class="language-cpp">if (from-&gt;type() != to-&gt;type()) {
    /* can't do automatic conversion from closure */
    if (from-&gt;type() == SocketType::CLOSURE) {
        fprintf(stderr,
                &quot;Cycles shader graph connect: can only connect closure to closure &quot;
                &quot;(%s.%s to %s.%s).\n&quot;,
                from-&gt;parent-&gt;name.c_str(),
                from-&gt;name().c_str(),
                to-&gt;parent-&gt;name.c_str(),
                to-&gt;name().c_str());
        return;
}

/* add automatic conversion node in case of type mismatch */
ShaderNode *convert;
ShaderInput *convert_in;

if (to-&gt;type() == SocketType::CLOSURE) {
    EmissionNode *emission = create_node&lt;EmissionNode&gt;();
    emission-&gt;set_color(make_float3(1.0f, 1.0f, 1.0f));
    emission-&gt;set_strength(1.0f);
    convert = add(emission);
    /* Connect float inputs to Strength to save an additional Falue-&gt;Color conversion. */
    if (from-&gt;type() == SocketType::FLOAT) {
        convert_in = convert-&gt;input(&quot;Strength&quot;);
    }
    else {
        convert_in = convert-&gt;input(&quot;Color&quot;);
    }
}
else {
    convert = add(create_node&lt;ConvertNode&gt;(from-&gt;type(), to-&gt;type(), true));
    convert_in = convert-&gt;inputs[0];
}

connect(from, convert_in);
connect(convert-&gt;outputs[0], to);
}
else {
    /* types match, just connect */
    to-&gt;link = from;
    from-&gt;links.push_back(to);
}
</code></pre>
<p>intern\render\cycles\nodes.cpp in the function <code>ConvertNode::constant_fold</code>.</p>
<pre><code class="language-cpp">if (from == SocketType::FLOAT) {
    if (SocketType::is_float3(to)) {
        folder.make_constant(make_float3(value_float, value_float, value_float));
    }
}
else if (SocketType::is_float3(from)) {
    if (to == SocketType::FLOAT) {
        if (from == SocketType::COLOR) {
            /* color to float */
            float val = folder.scene-&gt;shader_manager-&gt;linear_rgb_to_gray(value_color);
            folder.make_constant(val);
        }
        else {
            /* vector/point/normal to float */
            folder.make_constant(average(value_vector));
        }
    }
    else if (SocketType::is_float3(to)) {
        folder.make_constant(value_color);
    }
}
</code></pre>
<p>intern\cycles\render\shader.cpp</p>
<pre><code class="language-cpp">rgb_to_y = make_float3(0.2126729f, 0.7151522f, 0.0721750f);

float ShaderManager::linear_rgb_to_gray(float3 c)
{
  return dot(c, rgb_to_y);
}
</code></pre>
<h1><a class="header" href="#the-basics-of-the-math-node" id="the-basics-of-the-math-node">The basics of the math node</a></h1>
<p>We will start from this node tree:</p>
<p><img src="mnode/images/mn1.png" alt="Starting node group" /></p>
<p>We will go into more detail on coordinates in a later chapter, for now all you need to know is that the object coordinates are centered at the object origin, and go from -1 to 1 in all three axes in this case. The <code>Separate XYZ</code> node allows us to only look at one axis at a time, in this case the x-axis. The viewer node is just a renamed <code>Emission Shader</code> node.</p>
<h2><a class="header" href="#thinking-in-terms-of-ranges" id="thinking-in-terms-of-ranges">Thinking in terms of ranges</a></h2>
<p>The current output shows black in the left half and grey values going to white in the right half. This is one way to describe the output, but from this it is not so clear what the actual output values are. A better way to think about the output image is as a <em>linear gradient from -1 to 1</em>. The <em>range</em> of the gradient is <code>[-1, 1]</code> in this case. What this means is that the pixel value as you move from one side to the other changes from -1 to 1. The change here is along the x axis and goes from left to right (from lower values to bigger values). Because values below 0 are displayed as black, the left half of the image is black. If the gradient was along the y-axis then it would be going from the bottom to the top. </p>
<p>In addition to the range of values, we can also talk about the <em>shape</em> of the gradient. In this case the shape is linear, because when we plot the value of each pixel as we move from left to right the plotted shape is a line:</p>
<p><img src="mnode/images/lin_grad.png" alt="Linear gradient" /></p>
<p>The most common shape is a linear gradient. </p>
<h2><a class="header" href="#the-math-node" id="the-math-node">The math node</a></h2>
<p>Now that we have learned about gradients and ranges, it is time to manipulate them. In this section we will look at the most basic operations: <code>Add</code>, <code>Subtract</code>, <code>Multiply</code> and <code>Divide</code>. What happens when we add a <code>Math</code> node in between the <code>Separate XYZ</code> node and the viewer node? The values that go into the viewer node will now first pass through the <code>Math</code> node. The <code>Math</code> node will apply an operation to the values that are passed in, and return a new value. By default the <code>Math</code> node is set to <code>Add</code>, and both values set to 0.5. The <code>Add</code>, <code>Subtract</code>, <code>Multiply</code> and <code>Divide</code> modes only affect the range and not the shape.</p>
<p><img src="mnode/images/mn2.png" alt="Node setup" /></p>
<h3><a class="header" href="#add-and-subtract" id="add-and-subtract">Add and Subtract</a></h3>
<p>Currently the range is <code>[-1, 1]</code> . When it passes through the math node 0.5 is added to every value in the range. Luckily we don't need to think about what happens to every value in the range. We only need to look at the the two endpoints, i.e -1 and 1. Because we add 0.5 to everything, the range changes from <code>[-1, 1]</code> to <code>[-0.5, 1.5]</code> . You can think of this as moving the line 0.5 units upwards or moving the gradient 0.5 units to the left, whichever is more intuitive for you. </p>
<p>If we now change the value of the <code>Add</code> node, the range will move left or right. Increasing the value of the second input means we make the values in the range bigger, causing them to move to the right on the number line. This means, however, that the darker values will move to the left in the range, and because of that we perceive it as moving the image to the left. If we instead add negative values the result is the complete opposite.</p>
<p>A good way to see this, is to think about the middle value or center of the range. The center of a range represents its position. We can calculate the center of the range <code>[a, b]</code> as
\[\frac{a+b}{2}\]
If the range is <code>[-1, 1]</code> then the center is at 0. When we add 0.5 the new range is <code>[-0.5, 1.5]</code> and the center is now at 0.5. The old center, 0, is no longer in the center of the range but has moved to the left in the range, i.e. the old center is to the left of the new center. We will therefore see it as moving to the left. If we subtract values by changing the mode to <code>Subtract</code> or by adding negative values, the range will move to the left and the old center will move to the right of the new center.</p>
<p>In conclusion, the <code>Add</code> mode allows us to reposition a range. This is sometimes referred to as translation. If we want to move things to the left we add positive numbers, and if we want to move things to the right we add negative numbers.</p>
<h3><a class="header" href="#multiply-and-divide" id="multiply-and-divide">Multiply and Divide</a></h3>
<p>We have now seen how to position a range. If this was the only thing we could do with ranges we would be very limited. Luckily the <code>Multiply</code> mode allows us to scale the range. To see how this works let's look at an example once again.</p>
<p><img src="mnode/images/mn3.png" alt="Multiply node" /></p>
<p>The input range is <code>[-1, 1]</code> , and we multiply everything by 0.5. This means that the new range is now <code>[-0.5, 0.5]</code> . The center of the old range was 0, and that of the new range is still 0. Therefore the position has not changed. What has changed however is the (signed) length of the range, which we can calculate as follows: 
\[ b-a \]
The length of the range <code>[-1, 1]</code> is 2, while the length of the new range, <code>[-0.5, 0.5]</code> , is 1. This is exactly \(0.5*2\), so the length of the old range multiplied by the value in the we gave as input. The length of the range has decreased, which we perceive visually as zooming in. If we were to multiply by a value greater than 1, say 2, then the length would increase giving the effect of zooming out. In addition to increasing or decreasing the length of the range, we can also think of multiplying as darkening or brightening an image. If we multiply by a value less than 1, the values get darker. If we multiply by a value greater than 1 the values get brighter.</p>
<p>What happens if you multiply by a negative number? Let's say we multiply the range <code>[-1, 1]</code> with -1, then the new range is <code>[1, -1]</code> . We have flipped the range! This range has a signed length of -2, this means that instead of increasing from left to right, it now goes from right to left. Visually we perceive this as mirroring the range.</p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>To move, translate or reposition a range we can use the <code>Add</code> or <code>Subtract</code> mode. To resize, scale or flip a range we can use the <code>Multiply</code> or <code>Divide</code> mode.</p>
<hr />
<h2><a class="header" href="#example-map-range-node-from-scratch" id="example-map-range-node-from-scratch">Example: map range node from scratch</a></h2>
<p>To put our newly learned skills to the test we will recreate the map range node from scratch. The map range node is a very useful node that lets you go from one range to another, by specifying the endpoints. If we wanted to convert the range <code>[-1, 1]</code> to <code>[0.5, 2]</code> we would use these settings:</p>
<p><img src="mnode/images/map_range.png" alt="map range node" /></p>
<h3><a class="header" href="#steps-needed" id="steps-needed">Steps needed</a></h3>
<p>To convert from one range <code>[a, b]</code> to the other <code>[c, d]</code> we will use the following steps:</p>
<ol>
<li>Subtract <code>a</code> from the range. This will convert it to the range <code>[0, b-a]</code> .</li>
<li>Make the input range have length 1 by dividing by its length \((b-a)\). The new range is now <code>[0, 1]</code> . In many cases when working with ranges, you want to work with a range from 0 to 1, or <code>[-1, 1]</code> . The reasons for this will become clear when we start changing the shape.</li>
<li>Resize the range to the length of the output range by multiplying by \(d-c\). The range is now <code>[0, d-c]</code> . It already has the correct length.</li>
<li>We position the range so that the endpoints match, by adding <code>c</code>. The new range is now <code>[c, d]</code> . This is the result we wanted.</li>
</ol>
<p>For the more mathematically inclined, the full formula looks like this:
\[
\frac{x-a}{b-a}(d-c) + c
\]
where \(x\) is the input range.</p>
<h3><a class="header" href="#the-node-setup" id="the-node-setup">The node setup</a></h3>
<p>Add a math node between the separate xyz and the viewer node. Select it and press <code>Ctrl + G</code> to make it into a node group. Open up the side panel by pressing <code>N</code> to add extra inputs to the node group. Make sure you have 5 inputs then rename them to something by which you can recognize them. </p>
<p><img src="mnode/images/map_range2.png" alt="map range 2" /></p>
<p>We will now follow the steps from above but using math nodes. If I refer to socket names, they are the same as in the picture. Notice how the computations with ranges we described earlier are easily translated to operations with the math node.</p>
<ol>
<li>Change the mode of the math node to &quot;Subtract&quot;, and connect the <code>A</code> socket with the second input of the <code>Subtract</code> node.</li>
<li>Add a <code>Divide</code> node between the <code>Subtract</code> node and the group output. Copy the <code>Subtract</code> node (<code>Shift + D</code>), and connect the <code>B</code> socket to the second input and the <code>A</code> socket to the first input. (This node will thus compute B - A. Then plug the result of this <code>Subtract</code> node into the second input of the <code>Divide</code> node.</li>
</ol>
<p><img src="mnode/images/map_range3.png" alt="map range 3" /></p>
<ol start="3">
<li>Add a <code>Multiply</code> node after the <code>Divide</code> node, and a <code>Subtract</code> node below the other <code>Subtract</code> nodes. Plug the <code>C</code> socket into the second input of the <code>Subtract</code> node and the <code>D</code> socket into the first input. Then plug the result of that into the second input of the <code>Multiply</code> node.</li>
<li>Now just add an <code>Add</code> node after the <code>Multiply</code> node and plug the <code>C</code> socket into the second input.</li>
</ol>
<p>It is also be possible to use the <code>Multiply Add</code> node to combine the last two steps into one node. The way we did it makes the correspondence clearer between the steps we set at the beginning, and is thus preferable for educational purposes.</p>
<p><img src="mnode/images/map_range4.png" alt="Final setup" /></p>
<h4><a class="header" href="#final-example" id="final-example">Final example</a></h4>
<p>Here is a simple example where we used the map range node group to change the range of a noise texture:</p>
<p><img src="mnode/images/map_range5.png" alt="map range example" /></p>
<h1><a class="header" href="#shape" id="shape">Shape</a></h1>
<p>We have just learned how to transform a range using the <code>Math</code> node. Now it is time to also change the shape, for which we will be using the <code>Math</code> node as well. The functions that we will be looking at are <code>Power</code>, <code>Sine</code>, <code>Smoothstep</code> and <code>Smootherstep</code>.</p>
<h2><a class="header" href="#power" id="power">Power</a></h2>
<p>The <code>Power</code> mode of the math node is a powerful tool that allows us to change the shape or interpolation of a gradient. The mathematical operation is \(a^b\), as is also shown in the tooltip. There are two ways to use this:</p>
<ol>
<li>We let <code>a</code> be constant, and plug the range into the <code>b</code> socket. This gives us an exponential function with base <code>a</code>. If we chose <code>a</code> to be 2, for example, then we would get the function \(2^x\). The exponential function is not so useful when changing the shape, but comes up a lot in mathematical formulas. </li>
<li>In the other case we make <code>b</code> constant and plug the range into the <code>a</code> socket. In this case we are raising the range to the <code>b</code>-th power. This is something that we will use a lot in the future. We will refer to it as the power function from now on.</li>
</ol>
<p>The two functions look like this:</p>
<iframe src="https://graphtoy.com/?f1(x,t)=(sin(t)+1)*5&v1=false&f2(x,t)=pow(f1(x,t),x)&v2=true&f3(x,t)=pow(x,f1(x,t))&v3=true&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=-0.221702458210423,1.253803500548723,2.3859407407407427"
name="Power and Exponential function" height = "700" style="border: none;display: block; margin: 2 auto; width: 100%"></iframe>
<p>The constant value is animated through time between 0 and 10 by a sine wave, an incredibly useful function that we will cover soon. Feel free to experiment by changing the values of the functions.</p>
<p>Here are some observations we can make from the graph</p>
<ul>
<li>The functions seem to flip at a certain threshold, to be exact at a value of 1.</li>
<li>The power function is only shown on the right hand side (the positive x axis).</li>
<li>The power function always passes through the points <code>(0,0)</code> and <code>(1,1)</code>, and is constantly rising (i.e. as you move from right to left the values increase). </li>
<li>The exponential function always passes through <code>(0,1)</code>.</li>
</ul>
<p>The third property is the most important one. Another way to formulate it is as follows: &quot;If you plug a <code>[0, 1]</code> range in the power function, you get back a <code>[0, 1]</code> range, but with a different shape&quot;. This property is also true for the other functions that we will be looking at. If we look at the shape of the curve, we can see that it is not flat at the points <code>(0,0)</code>and <code>(1,1)</code>. This means that we might get sharp transitions when combining this function with others. The following three functions fix this problem.</p>
<h2><a class="header" href="#sine-smooth-and-smoother" id="sine-smooth-and-smoother">Sine, Smooth and Smoother</a></h2>
<p>We will limit ourselves to the range <code>[0, 1]</code> for these functions, as this makes things considerably easier. At the end of the section we will see how we can overcome this limitation.</p>
<h3><a class="header" href="#derivatives" id="derivatives">Derivatives</a></h3>
<p>To make a function that is flat at the edges, we first have to define what it means for a function to be flat. Intuitively a function can be considered flat at a point, if we can balance a book on the graph of the function. A more mathematical way would be to say that the function has a slope or derivative of zero at that point. Intuitively the slope says by how much a function is rising at that point. If the slope is negative, the function is decreasing, and if the slope is positive it is increasing. When the slope is 0, it is neither increasing nor decreasing and thus flat. The following image illustrates the different concepts we just talked about.</p>
<p><img src="mnode/images/derivatives.png" alt="Derivatives illustration" /></p>
<p>What follows is a bit more of a technical explanation, so feel free to skip over it and go straight to the <a href="mnode/shape.html#summary">summary</a>.</p>
<h3><a class="header" href="#construction-of-the-functions" id="construction-of-the-functions">Construction of the functions</a></h3>
<p>The simplest kinds of functions are the polynomials, they form the building blocks for more complex functions. Not only are they simple to write down, they can also be evaluated very quickly, making them ideal for computer graphics. Another useful property of polynomials is that through \(n+1\) distinct points, there is a unique polynomial of degree \(n\), a more general formulation of the well known property that two points determine a line. So what degree polynomial do we need to get a function that satisfies the properties we want? The properties are:</p>
<ul>
<li>Goes through <code>(0,0)</code> and <code>(1,1)</code></li>
<li>It is flat at <code>(0,0)</code> and <code>(1,1)</code></li>
</ul>
<p>These are four conditions, meaning that we have a unique polynomial of degree 3 which satisfies these properties. This polynomial, commonly known as <code>Smoothstep</code>, looks like this
<img src="mnode/images/smoothstep.png" alt="Smoothstep" />
\[
-2x^3+3x^2 = x\cdot x\cdot (3-2\cdot x)
\]
The right hand side of the equation is the one used in computer graphics, because it requires less computational steps to evaluate than the one on the left. Anyone who has had an introduction to calculus should be able to verify that this function does indeed meet the constraints. This function satisfies the properties we have described, but is not &quot;smooth&quot; enough in some cases. To fix this we use the so-called <code>Smootherstep</code>, which adds two extra conditions.</p>
<ul>
<li>Goes through <code>(0,0)</code> and <code>(1,1)</code></li>
<li>It is flat at <code>(0,0)</code> and <code>(1,1)</code></li>
<li>The second derivative (the derivative of the derivative) is flat at <code>(0,0)</code> and <code>(1,1)</code></li>
</ul>
<p>The new conditions ensure that the boundaries are very flat. Because we have 6 conditions, we now need a degree 5 polynomial.
<img src="mnode/images/smootherstep.png" alt="Smootherstep" /> 
\[
6x^5-15x^4+10x^3 = x\cdot x\cdot x\cdot (x\cdot (x\cdot 6-15)+10)
\]</p>
<p>What if we don't want to use polynomials? In that case, good candidates are the trigonometric functions like <code>Sine</code>, <code>Cosine</code> and <code>Tangent</code>. The problem here is that they are more expensive to evaluate, and less suited for the task. Another reason, is that they are approximated very well by polynomials. In fact any continuous function on a closed interval can be approximated as closely as desired by polynomials. This result is known as the Stone-Weierstrass theorem. This means that we are finding more complex polynomials to solve the same problems. If we do want to use <code>Sine</code>, we have to do some transforms on ranges to get it to line up. We will go into more detail on the <code>Sine</code> function when we talk about repetitions.</p>
<p><img src="mnode/images/sin.png" alt="Sine wave" /></p>
<p>The value of <code>Sine</code>, goes from -1 to 1 as the input goes from \(-\pi/2\) to \(\pi/2\). Luckily for us it's already flat at the edges. Our goal is to make it go from 0 to 1 as the input goes from 0 to 1. To do this, we can use similar steps to the ones we used for the <code>Map Range</code> node. To go from <code>[-1,1]</code> to <code>[0,1]</code>, we simply add 1 and divide by 2. For the input we multiply \(x\) by \(\pi\) and add \(-\pi/2\). The final function looks like this:
\[
\frac{\sin(\pi x - \pi /2)+1}{2}
\]</p>
<h2><a class="header" href="#different-ranges" id="different-ranges">Different ranges</a></h2>
<p>To make the functions work on ranges other than <code>[0,1]</code> we can use the steps we used to create the <code>Map Range</code> node from scratch, with one new step in the middle. Like before, we have an input and an output range, e.g. <code>[a,b]</code> and <code>[c,d]</code>.</p>
<ul>
<li>First remap the range to <code>[0,1]</code> by subtracting <code>a</code> and dividing by <code>b</code> - <code>a</code>.</li>
<li>At this point it is possible that the values exceed the <code>[0,1]</code> range, if the actual input exceeded the <code>[a,b]</code> range. To fix this we <code>Clamp</code> the input between 0 and 1, i.e. values less than 0 go to 0, and values greater than 1 go to 1. Now we apply the function to the clamped range.</li>
<li>We can now remap the range (with a changed shape) from <code>[0,1]</code> to <code>[c,d]</code>, by multiplying by <code>d</code> - <code>c</code> and adding <code>c</code>.</li>
</ul>
<p>The updated node group looks like this:</p>
<p><img src="mnode/images/map_range_smooth.png" alt="Smoothstep version of map range" /></p>
<p>Making the <code>Smoothstep</code> node group is left as an exercise. This now has basically the same functionality as the actual <code>Map Range</code> node.</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>Here is a plot of all the functions we looked at.</p>
<iframe src="https://graphtoy.com/?f1(x,t)=(sin(t)+1)*5&v1=false&f2(x,t)=x&v2=false&f3(x,t)=pow(x,f1(x,t))&v3=true&f4(x,t)=x*x*(3-2*x)&v4=true&f5(x,t)=(sin(x*PI-PI/2)+1)/2&v5=true&f6(x,t)=x*x*x*(x*(x*6-15)+10)&v6=true&grid=true&coords=0.5,0.5,0.6666666666666666"
name="Different shapes" height = "700" style="border: none; display: block; margin: 2 auto; width: 100%"> </iframe><h1><a class="header" href="#repetition" id="repetition">Repetition</a></h1>
<p>It is very often the case that some pattern appears multiple times on the same material. Think of things like floor tiles, honeycombs, fabrics etc. In this case it is useful to be able to work on one instance of the pattern, and then have it repeat multiple times automatically. The way that we can do this in shaders is by manipulating the input ranges of our pattern to repeat themselves. We can then add some imperfections on top to break up the pattern. Once we move to more dimensions we will see that this is a very powerful tool for creating all sorts of procedural shaders.</p>
<p><img src="mnode/images/fabric_pattern.jpg" alt="Fabric Pattern" /></p>
<h2><a class="header" href="#creating-a-repetition" id="creating-a-repetition">Creating a repetition</a></h2>
<p>The easiest way to create a repeating range is to use the <code>Fract</code> mode of the <code>Math</code> node. It takes the decimal or fractional part of a number and discards the rest. This means that 0.7 gets sent to 0.7 but 1.24 gets sent to 0.24. Let's take a look at what happens when we plug the range <code>[0, 2]</code> in. The values less than 1 will stay the same, for the other values the &quot;1&quot; in front will be removed, and we'll get a duplicate of the range <code>[0,1]</code>. Like this we have created a repetition of the range <code>[0,1]</code>. The <code>Fract</code> mode is a specific case of the more general <code>Modulo</code> operation. </p>
<p>The <code>Modulo</code> operation takes in an additional argument, the point at which we want to start wrapping. For <code>Fract</code> we start wrapping at one, i.e. once we have more than just a decimal part. If we instead start wrapping at two, for example, then the range <code>[0,2]</code> stays unchanged, except for the point 2, which wraps back to 0. The range <code>[0,4]</code> gets sent to two copies of the range <code>[0,2]</code>. Experiment with the <a href="mnode/repetition.html#graphs">graphs</a> to get a better feel for how it works. </p>
<p>Another function that we can use is the <code>Sine</code> function. We already encountered it in the previous section. It also repeats ranges, but in a smooth way. Unlike the <code>Modulo</code> operation, the shape of the range gets changed by the <code>Sine</code> function. It also differs in the fact that it wraps at \(2\pi\), the circumference of a unit circle. This is no coincidence, because the <code>Sine</code> function can be seen as the height of a point that is moving around a circle. Once the point has completed a full journey around the circle, the pattern repeats.</p>
<h3><a class="header" href="#magic" id="magic">Magic?</a></h3>
<p>With the functions described above, we can easily create a repetition where a change to one of the copies is repeated across all other copies. You can easily test this yourself in blender. Start from the following node group and try changing the nodes that come afterwards. You will see that the pattern changes in all copies!</p>
<p><img src="mnode/images/repetition.png" alt="Repetition node group" /></p>
<p>As an exercise you can try to change the nodes so that the repetition uses the <code>Sine</code> function instead. Hint: you will need to remap the range to <code>[0, 2*pi]</code> before using the <code>Sine</code> function, if you want the number of repetitions to be correct.</p>
<h3><a class="header" href="#graphs" id="graphs">Graphs</a></h3>
<iframe src="https://graphtoy.com/?f1(x,t)=fract(x)&v1=true&f2(x,t)=mod(x,%202)&v2=true&f3(x,t)=sin(x)&v3=true&f4(x,t)=floor(x)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,15.972000000000234"
name="Repetition" height = "700" style="border: none; display: block; margin: 2 auto; width: 100%"> </iframe>
<h2><a class="header" href="#accessing-individual-elements-in-a-repetition" id="accessing-individual-elements-in-a-repetition">Accessing individual elements in a repetition</a></h2>
<p>So what if we want to break up the pattern? If we add some noise after the repetition, it doesn't break up the pattern because the noise will be repeated too. If we add it before the repetition, then the pattern will be distorted. We need to split the range into two parts: the repeated pattern, and the variation for each copy. We have already tackled the repetition, we will now handle the variation. For this we will use the <code>Floor</code> mode.</p>
<p>While the <code>Fract</code> mode takes the fractional part, the <code>Floor</code> mode takes the whole number part. (For negative numbers this is not entirely true, but that doesn't really matter for what we will use it for). The graph of the <code>Floor</code> function looks like a staircase. The <code>Fract</code> and the <code>Floor</code> mode also have a very nice mathematical relationship: <code>fract(x) + floor(x) = x</code>. This is because the <code>Floor</code> function tells us in which copy we are, while the <code>Fract</code> function tells us where in the copy we are. The combined information says exactly where we are. The <code>Floor</code> function has only one value per copy. This means that any noise that use after the <code>Floor</code> function will have the same value on one copy, but different values for each copy. </p>
<h2><a class="header" href="#example-1d-noise" id="example-1d-noise">Example: 1D noise</a></h2>
<p>These explanations are all nice and well, but let's have a look at how we can actually use them. If we want a random value per pixel, we can use the <code>White Noise Texture</code> node. More often than not, we instead want a smooth kind of noise. For this we can use the <code>Noise Texture</code>. We will now see how you can use the <code>White Noise</code> texture to make the <code>Noise Texture</code> in the one-dimensional case.</p>
<h3><a class="header" href="#repetition-1" id="repetition-1">Repetition</a></h3>
<p>Because we are in search of &quot;smooth&quot; noise, we don't want a random value per pixel. Instead, we want to have control over the spacing of the random values. We will then interpolate between the different values to create a smooth transition. The first node tree looks like this: </p>
<p><img src="mnode/images/1d_noise.png" alt="1D Noise 1" /></p>
<p>It just gives us a random value per cell/copy of the input range. This works because the <code>Floor</code> function is constant over each copy, and thus the random value from the <code>White Noise Texture</code> is also constant for each copy.</p>
<h3><a class="header" href="#interpolation" id="interpolation">Interpolation</a></h3>
<p>To interpolate between two values, we first need two values. Currently we only have one value, i.e. the one generated by the white noise texture. For the second value we will use the random value of the copy to the right. To access this value we can just shift the input range by 1, because the ranges are wrapped at 1. You can verify for yourself that this works by comparing the outputs of the two <code>White Noise Texture</code> nodes.</p>
<p><img src="mnode/images/1d_noise2.png" alt="1D Noise 2" /></p>
<p>The interpolation itself is easy now. We just need to add a <code>Map Range</code> node. For the <code>Value</code> socket we can plug in the ranges generated by the <code>Fract</code> node. Since these go from 0 to 1 we can leave the <code>From min</code> and <code>From max</code> sockets unchanged. For the <code>To min</code> socket we can use the first randomly generated value, and for the <code>To max</code> socket we can use the value of the copy to the right. This will make it so that the values transition from the value of this copy to the value of the right copy as we move from left to right. As a final step we can set the interpolation mode to &quot;Smootherstep&quot; to get a smooth shape as a result.</p>
<p><img src="mnode/images/1d_noise3.png" alt="1D Noise 3" /></p>
<h3><a class="header" href="#layers" id="layers">Layers</a></h3>
<p>The observant among you may have noticed that the <code>Noise Texture</code> node has more options than just <code>Scale</code>. This is because it uses <code>Fractal Brownian Motion</code>. Multiple copies of the node group that we have just made are added on top each other with decreasing scales. The <code>Detail</code> socket controls how many layers. The <code>Roughness</code> socket determines by how much we scale down the consequent layers, so that the smaller details will contribute less to the final result. Although we can add layers manually by copying our node groups, there is currently no way to procedurally control how many layers we have. For that reason we will not implement this aspect of the <code>Noise Texture</code> node in our version.</p>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<p>If you are interested in learning more about shaders, these resources might be what you're looking for.</p>
<h2><a class="header" href="#blender-specific-resources" id="blender-specific-resources">Blender specific resources</a></h2>
<ul>
<li>The blender <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/">documentation</a> on shader nodes gives a description of each node and contains some examples as well.</li>
<li>The very nice community of the <a href="https://discord.gg/C7AGyf9fxW">erindale.xyz</a> discord server, focused on procedural things in blender.</li>
</ul>
<h2><a class="header" href="#shader-resources" id="shader-resources">Shader resources</a></h2>
<ul>
<li><a href="https://thebookofshaders.com/">The book of shaders</a> is a great resources for learning shaders using WebGL. </li>
<li>A whole lot of <a href="https://iquilezles.org/www/index.htm">articles</a> on computer graphics by Inigo Quilez.</li>
<li>The <a href="https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg">Art of Code</a> youtube channel has very good tutorials for writing shaders with Shadertoy.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
